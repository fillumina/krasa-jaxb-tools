package com.sun.tools.xjc.addon.krasa.validations;

import com.sun.codemodel.JFieldVar;
import com.sun.tools.xjc.model.CAttributePropertyInfo;
import com.sun.tools.xjc.model.CElementPropertyInfo;
import com.sun.tools.xjc.model.CPropertyInfo;
import com.sun.tools.xjc.model.CValuePropertyInfo;
import com.sun.tools.xjc.outline.ClassOutline;
import com.sun.tools.xjc.outline.Outline;
import com.sun.xml.xsom.XSComponent;
import com.sun.xml.xsom.XSParticle;
import com.sun.xml.xsom.XSSimpleType;
import com.sun.xml.xsom.XSTerm;
import com.sun.xml.xsom.XSType;
import com.sun.xml.xsom.impl.*;
import java.lang.annotation.Annotation;
import java.util.List;

/**
 * Performs the actual job of creating the annotations. The classes are generated by XJC.
 *
 * @author Francesco Illuminati
 */
public class Processor {

    private final ValidationsOptions options;

    public Processor(ValidationsOptions options) {
        this.options = options;
    }

    /**
     * Call at each generated class.
     *
     * @param model
     */
    public void process(Outline model) {
        for (ClassOutline classOutline : model.getClasses()) {
            String className = classOutline.implClass.name();

            // the properties for each class
            List<CPropertyInfo> properties = classOutline.target.getProperties();

            for (CPropertyInfo property : properties) {

                String propertyName = property.getName(false);

                ValidationsLogger logger = options.isVerbose()
                        ? new SystemOutValidationsLogger(className, propertyName)
                        : SilentValidationLogger.INSTANCE;

                new TypeProcessor(classOutline, logger).processProperty(property);
            }
        }
    }

    class TypeProcessor {

        private final ValidationsLogger logger;
        private final ClassOutline classOutline;

        public TypeProcessor(ClassOutline classOutline, ValidationsLogger logger) {
            this.logger = logger;
            this.classOutline = classOutline;
        }

        public void processProperty(CPropertyInfo property) {
            if (property instanceof CElementPropertyInfo) {
                processElement((CElementPropertyInfo) property);

            } else if (property instanceof CAttributePropertyInfo) {
                processAttribute((CAttributePropertyInfo) property);

            } else if (property instanceof CValuePropertyInfo) {
                processAttribute((CValuePropertyInfo) property);
            }
        }

        /**
         * parses xsd:element
         */
        private void processElement(CElementPropertyInfo property) {
            String propertyName = property.getName(false);

            XSParticle particle = (XSParticle) property.getSchemaComponent();
            XSTerm term = particle.getTerm();
            final JFieldVar field = classOutline.implClass.fields().get(propertyName);
            FieldAnnotator annotator =
                    new FieldAnnotator(field, options.getAnnotationFactory(), logger);

            if (term instanceof ModelGroupImpl) {
                processModelGroupIml(annotator);
            } else if (term instanceof ElementDecl) {
                processElementDecl(property, field, particle, (ElementDecl) term, annotator);
            }
        }

        private void processModelGroupIml(FieldAnnotator annotator) {
            annotator.addValidAnnotation();
        }

        /**
         * parses xsd:element
         */
        private void processElementDecl(
                CElementPropertyInfo property,
                JFieldVar field,
                XSParticle particle,
                ElementDecl element,
                FieldAnnotator annotator) {

            // used for debugging...
            final String name = property.getName(true);
            final int minOccurs = particle.getMinOccurs().intValue();
            final int maxOccurs = particle.getMaxOccurs().intValue();
            final boolean required = property.isRequired() || property.isCollectionRequired();
            final boolean nillable = element.isNillable() || property.isCollectionNillable();
            final String targetNamespace = element.getOwnerSchema().getTargetNamespace();

            final XSType elementType = element.getType();
            final boolean isComplexType = elementType.isComplexType();
            final FieldHelper fieldHelper = new FieldHelper(field);

            // minOccurs > 0 and required == false means the attribute is part of a <xsd:choice>
            // and @NotNull should not be added so only required quilifies to add @NotNull
            if (options.isNotNullAnnotations() && !nillable && required) {
                String message = notNullMessage(classOutline, field);
                annotator.addNotNullAnnotation(classOutline, field, message);
            }

            boolean multiElementCollection = property.isCollection() && (minOccurs != 1 || maxOccurs != 1);
            if (multiElementCollection) {
                annotator.addSizeAnnotation(minOccurs, maxOccurs, null);
            }

            if ((property.isCollection() || isComplexType) &&
                    Utils.isEqualsOrNull(options.getTargetNamespace(), targetNamespace))  {
                annotator.addValidAnnotation();
            }

            final XSSimpleType simpleType;
            if (isComplexType) {
                simpleType = elementType.getBaseType().asSimpleType();
            } else {
                simpleType = elementType.asSimpleType();
            }

            if (simpleType != null) {

                // if it's a complexyType it might add a facet referring to only one of the possibilities
                // using https://github.com/jirutka/validator-collection to annotate Lists of primitives
                AccumulatorFacet facet = HierarchyFacetGatherer.gatherRestrictions(simpleType);
                if (property.isCollection()) {
                    annotator.addSizeAnnotation(facet.minLength(), facet.maxLength(), facet.length());

                    if (multiElementCollection && options.isValidationCollection()) {
                        AccumulatorFacet simpleFacet = HierarchyFacetGatherer.gatherRestrictions(simpleType);
                        annotator.addEachSizeAnnotation(simpleFacet.minLength(), simpleFacet.maxLength());
                        annotator.addEachDigitsAnnotation(simpleFacet.totalDigits(), simpleFacet.fractionDigits());
                        annotator.addEachDecimalMinAnnotation(simpleFacet.minInclusive(), simpleFacet.minExclusive());
                        annotator.addEachDecimalMaxAnnotation(simpleFacet.maxInclusive(), simpleFacet.maxExclusive());
                        annotator.addEachPatterns(simpleFacet.getMultiPatterns(), options.isMultiPattern());
                    }
                    if (facet.getItemFacet() != null) {
                        facet = facet.getItemFacet();
                        processType(fieldHelper, annotator, facet);
                    }

                } else {

                    processType(fieldHelper, annotator, facet);

                }

            }
        }

        /**
         * parses xsd:attribute
         */
        private void processAttribute(CAttributePropertyInfo property) {
            String propertyName = property.getName(false);

            XSComponent definition = property.getSchemaComponent();
            if (definition instanceof AttributeUseImpl) {
                AttributeUseImpl particle = (AttributeUseImpl) definition;
                XSSimpleType type = particle.getDecl().getType();

                JFieldVar field = classOutline.implClass.fields().get(propertyName);

                if (field != null) {
                    FieldAnnotator annotator =
                            new FieldAnnotator(field, options.getAnnotationFactory(), logger);

                    if (particle.isRequired()) {
                        String message = notNullMessage(classOutline, field);
                        annotator.addNotNullAnnotation(classOutline, field, message);
                    }

                    processType(type, field, annotator);
                }
            }
        }

        /**
         * parses values
         *
         * NOTE: needed to process complexTypes extending a simpleType
         */
        private void processAttribute(CValuePropertyInfo property) {
            String propertyName = property.getName(false);

            XSComponent definition = property.getSchemaComponent();
            if (definition instanceof SimpleTypeImpl) {
                SimpleTypeImpl particle = (SimpleTypeImpl) definition;
                XSSimpleType simpleType = particle.asSimpleType();

                JFieldVar field = classOutline.implClass.fields().get(propertyName);

                if (field != null) {
                    FieldAnnotator annotator =
                            new FieldAnnotator(field, options.getAnnotationFactory(), logger);

                    processType(simpleType, field, annotator);
                }
            }
        }

        private void processType(XSSimpleType simpleType, JFieldVar field, FieldAnnotator annotator) {
            AccumulatorFacet facet = HierarchyFacetGatherer.gatherRestrictions(simpleType);
            FieldHelper fieldHelper = new FieldHelper(field);
            processType(fieldHelper, annotator, facet);
        }

        /**
         * Process types which are not collections
         */
        private void processType(
                FieldHelper fieldHelper,
                FieldAnnotator annotator,
                AccumulatorFacet facet) {

            annotator.addSizeAnnotation(facet.minLength(), facet.maxLength(), facet.length());

            if (fieldHelper.isNumber() || fieldHelper.isString()) {
                if (options.isAllNumericConstraints()) {
                    annotator.addDecimalMinAnnotationInclusive(facet.minInclusive());
                    annotator.addDecimalMinAnnotationExclusive(facet.minExclusive());
                    annotator.addDecimalMaxAnnotationInclusive(facet.maxInclusive());
                    annotator.addDecimalMaxAnnotationExclusive(facet.maxExclusive());

                } else {
                    annotator.addDecimalMinAnnotationInclusive(fieldHelper.validValue(facet.minInclusive()));
                    annotator.addDecimalMinAnnotationExclusive(fieldHelper.validValue(facet.minExclusive()));
                    annotator.addDecimalMaxAnnotationInclusive(fieldHelper.validValue(facet.maxInclusive()));
                    annotator.addDecimalMaxAnnotationExclusive(fieldHelper.validValue(facet.maxExclusive()));
                }
                annotator.addDigitsAnnotation(facet.totalDigits(), facet.fractionDigits());
            }

            annotator.addPatterns(((AccumulatorFacet)facet).getMultiPatterns(), options.isMultiPattern());
        }
    }


    String notNullMessage(ClassOutline classOutline, JFieldVar field) {
        final String className = classOutline.implClass.name();
        final Class<? extends Annotation> notNullClass = options.getAnnotationFactory()
                .getNotNullClass();

        String message = null;

        if (options.isNotNullPrefixClassName()) {
            message = String.format("%s.%s {%s.message}",
                    className, field.name(),
                    notNullClass.getName());

        } else if (options.isNotNullPrefixFieldName()) {
            message = String.format("%s {%s.message}",
                    field.name(),
                    notNullClass.getName());

        } else if (options.isNotNullCustomMessage()) {
            message = String.format("{%s.message}",
                    notNullClass.getName());

        } else if (options.getNotNullCustomMessageText() != null) {
            message = options.getNotNullCustomMessageText()
                    .replace("{ClassName}", className)
                    .replace("{FieldName}", field.name());
        }

        return message;
    }

}
